---
layout: post
title: "HashMap的hash优化与寻址优化"
date: 2020-11-21 
description: "HashMap的hash优化与寻址优化"
tag: Java基础
---   
## HashMap的hash优化与寻址优化

#### hash优化

>下面这段代码是HashMap的hash源码代码块
```
 static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

主要有下面这几个步骤

> 1：对key进行hash比如:

    1111 1111 1111 1111 1101 1011 1110 0101

> 2：对hash后的hash值进行右移16位   

    0000 0000 0000 0000 1111 1111 1111 1111
    

> 3：将原hash与右移后的hash值进行异或运算
    
    1111 1111 1111 1111 0010 0100 0001 1010 ->>>> int 值（32位）

##### 为什么这么做了？ 
    
    假如我们没有进行右移，则定位数组下标为（n-1）& hash，默认数组长度为16，则二进制为
    0000 0000 0000 0000 0000 0000 0000 1111
    
    假如hash的二进制与（n-1）进行与（&）运算
    
    1111 1111 1111 1111 1101 1011 1110 0101
                     &
    0000 0000 0000 0000 0000 0000 0000 1111
                     = 
    0000 0000 0000 0000 0000 0000 0000 0101
        
    我们发现高16位都没有参与运算，几乎可以忽略掉（&两位同时为1才为1）。核心是低16位的运算，高16位都没有参与进来。
    
    我们在回头看看上面源码的步骤
    
    hashcode   1111   1111    1111    1111    1101    1011   1110   0101 
    右移16位    0000   0000    0000    0000    1111    1111   1111   1111
    ^ 异或运算  1111    1111   1111    1111    0010 0100 0001  1010
    
    我们发现右移16位后的值的低16位就是原始值的高16位，而异或后的低16位，则是将原始值的高位低位进行运算后的值。而之前不进行右移，异或运算的方式，只将低位参与了运算；这样做的好处就是将高位地位都参与运算，避免hash冲突，缩小hash的冲突范围。
    
#### 寻址优化：hash%n 替换为 （n-1）&hash
    
    (hash%n)取模，对于除数是2的n次方取余操作;都可以写成（n-1）& hash。 两者其实效果是一样，只是后者比前者性能高很多。
    
