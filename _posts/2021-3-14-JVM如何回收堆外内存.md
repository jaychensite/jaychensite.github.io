---
layout: post
title: "JVM如何回收堆外内存"
date: 2021-3-14
description: "JVM如何回收堆外内存"
tag: JVM
---

#### jvm如何回收直接内存

因为直接内存不属于jvm垃圾回收的管辖范围内（直接内存是在 Java 堆外的、直接向系统申请的内存区间。）。那么jvm是如何回收直接内存了？

java中创建直接内存的方式如下：

```java
 int buff = 1024*1024*1024;
 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(buff);
```

通过存在堆中的 DirectByteBuffer对象 操作 Native 内存。

要想知道是如何回收直接内存，只有一个办法，看源码。

```java
// 我们先看看ByteBuffer的构造方法
public static ByteBuffer allocateDirect(int capacity) {
        return new DirectByteBuffer(capacity);
    }
// DirectByteBuffer
DirectByteBuffer(int cap) {                   // package-private

        super(-1, 0, cap, cap);
        boolean pa = VM.isDirectMemoryPageAligned();
        int ps = Bits.pageSize();
        long size = Math.max(1L, (long)cap + (pa ? ps : 0));
        Bits.reserveMemory(size, cap);

        long base = 0;
        try {
        		// 申请内存。返回虚拟内存地址
            base = unsafe.allocateMemory(size);
        } catch (OutOfMemoryError x) {
            Bits.unreserveMemory(size, cap);
            throw x;
        }
  			// 初始化
        unsafe.setMemory(base, size, (byte) 0);
        if (pa && (base % ps != 0)) {
            // Round up to page boundary
            address = base + ps - (base & (ps - 1));
        } else {
          	// 内存地址，对内存的读写需要
            address = base;
        }
        // 重点：这里涉及到垃圾回收
        // new Deallocator(base, size, cap)：Deallocator是DirectByteBuffer的静态内部类，用于清理内存工作
  			// 释放堆外内存
  
  			// 创建一个Cleaner对象：Cleaner后面会讲解。
  			// this:DirectByteBuffer对象，也就是Cleaner持有DirectByteBuffer对象
        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
        att = null;
    }
```

我们先看 Deallocator

```java
// Deallocator实现了Runnable

private static class Deallocator
        implements Runnable
    {

        private static Unsafe unsafe = Unsafe.getUnsafe();

        private long address;
        private long size;
        private int capacity;

        private Deallocator(long address, long size, int capacity) {
            assert (address != 0);
            this.address = address;
            this.size = size;
            this.capacity = capacity;
        }

				// run方法
        public void run() {
            if (address == 0) {
                // Paranoia
                return;
            }
            // 释放内存
            unsafe.freeMemory(address);
            address = 0;
            Bits.unreserveMemory(size, capacity);
        }

    }
```

那么问题来了Deallocator线程在哪里触发？

接着来看看Cleaner类

```java
// 我们发现Cleaner继承了PhantomReference（虚引用）
// Java 虚引用允许对象被回收之前做一些清理工作。
// PhantomReference对象存放在堆中

public class Cleaner extends PhantomReference<Object> {
	// 当一个对象被gc掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue即这样的一个对象
	// 比如反向操作，数据清理等。
  private static final ReferenceQueue<Object> dummyQueue = new ReferenceQueue();
 
 	// 线程的启动
  private final Runnable thunk;
 	
 	// 创建Cleaner
 	// var0：DirectByteBuffer对象
 	// var1：指的就是Deallocator
  public static Cleaner create(Object var0, Runnable var1) {
  			// new Cleaner(var0, var1) 创建 Cleaner
        return var1 == null ? null : add(new Cleaner(var0, var1));
    }
 
 // var1：DirectByteBuffer对象
 // var2：指的就是Deallocator
  private Cleaner(Object var1, Runnable var2) {
  			// 调用父类构造器（Reference）
        super(var1, dummyQueue);
        // 赋值
        this.thunk = var2;
    }
 
  // 重点
  // 当 DirectByteBuffer 被 GC 之前，cleaner 对象会被放入一个引用队列（ReferenceQueue）
  // JVM 会启动一个低优先级线程扫描这个队列，并且执行 Cleaner 的 clean 方法来做清理工作。
  public void clean() {
        if (remove(this)) {
            try {
            		// 启动清理线程
                this.thunk.run();
            } catch (final Throwable var2) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        if (System.err != null) {
                            (new Error("Cleaner terminated abnormally", var2)).printStackTrace();
                        }

                        System.exit(1);
                        return null;
                    }
                });
            }

        }
    }

}
```

上面提到JVM 会启动一个高优先级线程扫描这个队列，并且执行 Cleaner 的 clean 方法来做清理工作。

思考：这个后台线程是在哪里启动？？？

我们知道Cleaner继承了PhantomReference，而PhantomReference根本没做啥。我们发现PhantomReference继承了Reference

接下来分析一下Reference

```java
public abstract class Reference<T> {
  
   // 即Reference所包装的引用对象(真实对象)
   private T referent;         /* Treated specially by GC */
   // 引用队列，外部可以通过传递引用队列，方便后续判断 指定 对象是否被gc回收掉
   volatile ReferenceQueue<? super T> queue
   // 组装成ReferenceQueue队列，注意是单向列表 
     
   // 引用四种状态  
   /* When active:   NULL 激活。创建ref对象时就是激活状态
     *     pending:   this 等待入队。所对应的强引用被GC，就要入队，是GC线程做的
     *    Enqueued:   next reference in queue (or this if last) 入队了。守护线程，
     			如果指定了refQueue消费pending移动到enqueued状态。refQueue.poll时进入失效状态
     			如果没有指定refQueue，直接到失效状态。
     *    Inactive:   this 失效
     */  
   volatile Reference next;
  	
    /* When active:   next element in a discovered reference list maintained by GC (or this if last)
     *     pending:   next element in the pending list (or null if last)
     *   otherwise:   NULL
     */
  	// jvm 线程判断当前ref中的真实对象是垃圾后，会讲ref加入到当前的pending队列，pending是一个单向链表
  	// 使用discovered连接
    transient private Reference<T> discovered;  /* used by VM */
  	
  	/* List of References waiting to be enqueued.  The collector adds
     * References to this list, while the Reference-handler thread removes
     * them.  This list is protected by the above lock object. The
     * list uses the discovered field to link its elements.
     */
  	// pending 链表的头字段，pending元素追加操作，是由jvm垃圾收集器线程执行。
  	// 消费线程会从头开始消费，先进后出（头插法），后面会说到
    private static Reference<Object> pending = null;
  
   // 静态类
   static {
     		// 创建一个后台线程
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
     		// 处理引用队列线程
     		// ReferenceHandler:Reference内部静态类，继承了Thread
        Thread handler = new ReferenceHandler(tg, "Reference Handler");
        /* If there were a special system-only priority greater than
         * MAX_PRIORITY, it would be used here
         */
     		// 优先级很高的线程
        handler.setPriority(Thread.MAX_PRIORITY);
     		// 守护线程
        handler.setDaemon(true);
     		// 启动线程，就会进入ReferenceHandler
        handler.start();

        // provide access in SharedSecrets
        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
            @Override
            public boolean tryHandlePendingReference() {
                return tryHandlePending(false);
            }
        });
    }
  
   /* High-priority thread to enqueue pending References
     */
  	// 处理线程的代码
    private static class ReferenceHandler extends Thread {

        。。。。。。。。
          
				// 执行线程
        public void run() {
          	// 循坏处理
            while (true) {
              	// 消费处理pending队列里面的数据
                tryHandlePending(true);
            }
        }
    }
  
  // 具体处理Pending队列的逻辑
  static boolean tryHandlePending(boolean waitForNotify) {
        Reference<Object> r;
        Cleaner c;
        try {
          	// 加锁
          	// 思考：这里会存在线程竞争吗？
          	// pending队列是一个全局的变量，有两个地方会调用
            // 1:jvm垃圾收集器线程需要向pending队列追加ref引用对象（前面分析源码时提到过）
          	// 2:当前线程消费pending队列
          	// 这下明白为什么会加锁了吧
            synchronized (lock) {
              	// 判断头元素是否为空
                if (pending != null) {
                  	// 不为空则赋值给Cleaner
                    r = pending;
                    // 'instanceof' might throw OutOfMemoryError sometimes
                    // so do this before un-linking 'r' from the 'pending' chain...
                  	// C一般情况下为null，只有当r指向的 ref 实例是Cleaner实例，c才不会为空，并且指向Cleaner对象
                    c = r instanceof Cleaner ? (Cleaner) r : null;
                    // unlink 'r' from 'pending' chain
                  	// 出队列操作
                  	// pending 临时保存pengind队列的下一个元素
                    pending = r.discovered;
                  	// 置为null
                    r.discovered = null;
                } else {
                    // The waiting on the lock may cause an OutOfMemoryError
                    // because it may try to allocate exception objects.
                    if (waitForNotify) {
                      	// 如果pending为null，则会阻塞当前线程，释放锁。等待其它线程唤醒
                        // 唤醒线程是谁？？？
                      	// jvm垃圾回收器线程，时机在jvm线程追加pending队列之后，会唤醒此阻塞线程，让此线程去消费。
                      	// 简单来讲就是一个生产者消费者模式
                        lock.wait();
                    }
                    // retry if waited
                    return waitForNotify;
                }
            }
        } catch (OutOfMemoryError x) {
            // Give other threads CPU time so they hopefully drop some live references
            // and GC reclaims some space.
            // Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above
            // persistently throws OOME for some time...
            Thread.yield();
            // retry
            return true;
        } catch (InterruptedException x) {
            // retry
            return true;
        }

        // Fast path for cleaners
    		// 条件成立则说明当前是一个Cleaner类型的对象
        if (c != null) {
          	// 调用了Cleaner的clean方法
          	// 进行清理工作。就不会再执行 从pending队列转移到ReferenceQueue队列
            c.clean();
            return true;
        }
				// 大部分情况会走到这。c==null
    		// 获取	创建ref时指定的ReferenceQueue
        ReferenceQueue<? super Object> q = r.queue;
    		// 条件成立，则说明创建ref对象时指定了ReferenceQueue，则进行入队列
        if (q != ReferenceQueue.NULL) q.enqueue(r);
        return true;
    }
}
```

```java
ReferenceQueue
```

```java
boolean enqueue(Reference<? extends T> r) { /* Called only by Reference class */
        synchronized (lock) {
            // Check that since getting the lock this reference hasn't already been
            // enqueued (and even then removed)
            ReferenceQueue<?> queue = r.queue;
          	// 检查是否已经入过队，如果入过队了则返回
            if ((queue == NULL) || (queue == ENQUEUED)) {
                return false;
            }
            assert queue == this;
          	// 表示Reference变为入队状态
            r.queue = ENQUEUED;
          	// 头插法入队
            r.next = (head == null) ? r : head;
            head = r;
            queueLength++;
            if (r instanceof FinalReference) {
                sun.misc.VM.addFinalRefCount(1);
            }
            lock.notifyAll();
            return true;
        }
    }
```





#### 总结

我们回头再看看最开始的例子

```java
int buff = 1024*1024*1024;
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(buff);
```

此时jvm对象分配如图：

![image][image1]



byteBuffer强引用堆里面的DirectByteBuffer对象，DirectByteBuffer对象持有Cleaner对象，因为Cleaner是虚引用，因此也要指向DirectByteBuffer对象，而Cleaner对象又持有Deallocator对象（清理内存对象）。当byteBuffer断开强引用时，DirectByteBuffer就会被jvm当作垃圾回收。Cleaner本身是一个虚引用，此时就会进入pending队列。上面源码分析中提到过Reference中会后台起一个高优先级的消费线程去消费pending队列。消费队列时如果队列是Cleaner对象，则会调用Cleaner对象的clean方法。

clean方法核心代码

```java
 public void clean() {
        if (remove(this)) {
            try {
              	// 核心代码
              	// 前面说过thunk就是Deallocator对象
                this.thunk.run();
            } catch (final Throwable var2) {
               。。。。。。。。。
            }

        }
    }
```

clean方法中就会启动Deallocator线程，去清理堆外内存。







[image1]:data:image/jpeg;base64,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
